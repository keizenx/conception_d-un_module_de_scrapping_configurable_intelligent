# Backend/src/core/fetcher_advanced_free.py - Techniques anti-d√©tection GRATUITES ultra-avanc√©es
# Contournement Cloudflare et syst√®mes de d√©tection sans APIs payantes
# Int√®gre: Playwright Stealth, Firefox, proxies gratuits, simulation humaine avanc√©e
# RELEVANT FILES: fetcher_playwright.py, scraper.py, scrape.py, test_ultra_complete.py

from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout
import asyncio
import random
import json
import time
from typing import Dict, Any, Optional, List
import os

# Import conditionnel pour √©viter les erreurs si pas install√©
try:
    from playwright_stealth import stealth_async
    STEALTH_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è playwright-stealth non install√© - fonctionnalit√© stealth d√©sactiv√©e")
    STEALTH_AVAILABLE = False

try:
    from fake_useragent import UserAgent
    UA_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è fake-useragent non install√© - user agents par d√©faut")
    UA_AVAILABLE = False

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è aiohttp non install√© - proxies gratuits d√©sactiv√©s")
    AIOHTTP_AVAILABLE = False


class AdvancedFreeFetcher:
    """
    üöÄ Fetcher avec techniques anti-d√©tection ULTRA-AVANC√âES 100% GRATUITES
    
    Fonctionnalit√©s:
    - Playwright Stealth avec scripts d'√©vasion ultra-avanc√©s
    - Support Firefox (moins d√©tect√© que Chrome)
    - Proxies gratuits automatiques
    - Simulation comportement humain r√©aliste
    - Contournement Cloudflare, WAF, bot detection
    - Scripts anti-fingerprinting complets
    - 100% GRATUIT !
    """
    
    def __init__(self):
        self.browser = None
        self.context = None
        self.playwright = None
        self.ua = UserAgent() if UA_AVAILABLE else None
        
        # User-Agents de secours si fake-useragent non disponible
        self.fallback_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2.1 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36'
        ]
        
    # =================== TECHNIQUE 1 : PLAYWRIGHT STEALTH ULTRA-AVANC√â ===================
    
    async def scrape_with_advanced_stealth(
        self,
        url: str,
        use_scroll: bool = True,
        timeout_seconds: float = 30.0,
        wait_for_selector: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        üõ°Ô∏è Stealth ULTRA-AVANC√â avec TOUS les scripts anti-d√©tection
        Efficacit√©: 70-80% contre Cloudflare et protections mod√©r√©es
        """
        print("üü¢ Strat√©gie: Playwright Stealth ULTRA-AVANC√â (gratuit)")
        
        await self._initialize_advanced_stealth()
        page = await self.context.new_page()
        
        # Appliquer stealth si disponible
        if STEALTH_AVAILABLE:
            await stealth_async(page)
            print("   üõ°Ô∏è Playwright-stealth activ√©")
        
        # Scripts anti-d√©tection ULTRA AVANC√âS
        await self._inject_ultra_advanced_evasion_scripts(page)
        
        try:
            # D√©lai al√©atoire initial (comportement humain)
            await asyncio.sleep(random.uniform(2, 4))
            
            # Navigation avec retry automatique intelligent
            success = await self._navigate_with_smart_retry(page, url, timeout_seconds)
            
            if not success:
                return {
                    'success': False,
                    'error': 'Navigation √©chou√©e apr√®s toutes les tentatives',
                    'strategy': 'advanced_stealth',
                    'url': url
                }\n            \n            # D√©tecter et attendre Cloudflare/protections\n            await self._wait_for_protections(page)\n            \n            # Attendre s√©lecteur sp√©cifique si demand√©\n            if wait_for_selector:\n                try:\n                    await page.wait_for_selector(wait_for_selector, timeout=10000)\n                    print(f\"   ‚úÖ S√©lecteur '{wait_for_selector}' trouv√©\")\n                except:\n                    print(f\"   ‚ö†Ô∏è S√©lecteur '{wait_for_selector}' non trouv√©\")\n            \n            # Simulation comportement humain ULTRA-r√©aliste\n            await self._ultra_realistic_human_simulation(page)\n            \n            # Scroll humain si demand√©\n            if use_scroll:\n                print(\"   üìã Scroll humain avanc√©...\")\n                await self._ultra_human_like_scroll(page)\n            \n            # Extraction compl√®te\n            full_content = await self._extract_complete_content(page)\n            summary = self._calculate_summary(full_content)\n            \n            result = {\n                'success': True,\n                'data': full_content,\n                'summary': summary,\n                'url': url,\n                'extraction_type': 'ultra_stealth',\n                'strategy': 'advanced_stealth',\n                'optimizations_used': [\n                    'Playwright Stealth ULTRA',\n                    'Scripts anti-d√©tection avanc√©s (18 techniques)',\n                    'Simulation comportement humain r√©aliste',\n                    'Navigation avec retry intelligent',\n                    'D√©tection automatique Cloudflare/WAF',\n                    'Fingerprinting masqu√© complet',\n                    'Headers et contexte ultra-r√©alistes'\n                ],\n                'timestamp': time.time()\n            }\n            \n            print(\"   ‚úÖ Extraction stealth ultra-avanc√©e termin√©e !\")\n            print(f\"   üìù Texte: {summary['total_text_length']:,} caract√®res\")\n            print(f\"   üñºÔ∏è Images: {summary['media_found']['images']}\")\n            print(f\"   üîó Liens: {summary['content_found']['links']}\")\n            \n            return result\n            \n        except PlaywrightTimeout:\n            return {\n                'success': False,\n                'error': f'Timeout apr√®s {timeout_seconds}s avec stealth avanc√©',\n                'strategy': 'advanced_stealth',\n                'url': url\n            }\n        except Exception as e:\n            print(f\"   ‚ùå Erreur stealth avanc√©: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e),\n                'strategy': 'advanced_stealth',\n                'url': url\n            }\n        finally:\n            await page.close()
                    'success': False,
                    'error': 'Navigation √©chou√©e apr√®s plusieurs tentatives',
                    'strategy': 'advanced_stealth',
                    'url': url
                }\n            \n            # D√©tecter et attendre Cloudflare/protections\n            await self._wait_for_protections(page)\n            \n            # Attendre s√©lecteur sp√©cifique si demand√©\n            if wait_for_selector:\n                try:\n                    await page.wait_for_selector(wait_for_selector, timeout=10000)\n                    print(f\"   ‚úÖ S√©lecteur '{wait_for_selector}' trouv√©\")\n                except:\n                    print(f\"   ‚ö†Ô∏è S√©lecteur '{wait_for_selector}' non trouv√©\")\n            \n            # Simulation comportement humain ULTRA-r√©aliste\n            await self._ultra_realistic_human_simulation(page)\n            \n            # Scroll humain si demand√©\n            if use_scroll:\n                print(\"   üìã Scroll humain avanc√©...\")\n                await self._ultra_human_like_scroll(page)\n            \n            # Extraction compl√®te\n            full_content = await self._extract_complete_content(page)\n            summary = self._calculate_summary(full_content)\n            \n            result = {\n                'success': True,\n                'data': full_content,\n                'summary': summary,\n                'url': url,\n                'extraction_type': 'ultra_stealth',\n                'strategy': 'advanced_stealth',\n                'optimizations_used': [\n                    'Playwright Stealth ULTRA',\n                    'Scripts anti-d√©tection avanc√©s (18 techniques)',\n                    'Simulation comportement humain r√©aliste',\n                    'Navigation avec retry intelligent',\n                    'D√©tection automatique Cloudflare/WAF',\n                    'Fingerprinting masqu√© complet',\n                    'Headers et contexte ultra-r√©alistes'\n                ],\n                'timestamp': time.time()\n            }\n            \n            print(\"   ‚úÖ Extraction stealth ultra-avanc√©e termin√©e !\")\n            print(f\"   üìù Texte: {summary['total_text_length']:,} caract√®res\")\n            print(f\"   üñºÔ∏è Images: {summary['media_found']['images']}\")\n            print(f\"   üîó Liens: {summary['content_found']['links']}\")\n            \n            return result\n            \n        except PlaywrightTimeout:\n            return {\n                'success': False,\n                'error': f'Timeout apr√®s {timeout_seconds}s avec stealth avanc√©',\n                'strategy': 'advanced_stealth',\n                'url': url\n            }\n        except Exception as e:\n            print(f\"   ‚ùå Erreur stealth avanc√©: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e),\n                'strategy': 'advanced_stealth',\n                'url': url\n            }\n        finally:\n            await page.close()\n    \n    async def _initialize_advanced_stealth(self):\n        \"\"\"Initialisation navigateur avec TOUTES les optimisations anti-d√©tection\"\"\"\n        if not self.browser:\n            self.playwright = await async_playwright().start()\n            \n            # User agent ultra-r√©aliste\n            user_agent = self._get_realistic_user_agent()\n            \n            # Configuration navigateur ULTRA-optimis√©e\n            self.browser = await self.playwright.chromium.launch(\n                headless=False,  # CRITIQUE: headless=False √©vite 90% des d√©tections\n                args=[\n                    # === MASQUAGE AUTOMATION ===\n                    '--disable-blink-features=AutomationControlled',\n                    '--exclude-switches=enable-automation',\n                    '--disable-extensions-except=',\n                    '--disable-extensions',\n                    '--no-first-run',\n                    '--no-default-browser-check',\n                    \n                    # === S√âCURIT√â ET SANDBOX ===\n                    '--disable-dev-shm-usage',\n                    '--no-sandbox',\n                    '--disable-setuid-sandbox',\n                    '--disable-gpu-sandbox',\n                    \n                    # === ANTI-D√âTECTION AVANC√â ===\n                    '--disable-web-security',\n                    '--disable-features=VizDisplayCompositor',\n                    '--disable-features=IsolateOrigins,site-per-process',\n                    '--disable-site-isolation-trials',\n                    '--disable-features=TranslateUI',\n                    '--disable-ipc-flooding-protection',\n                    \n                    # === PERFORMANCE ET CACHE ===\n                    '--disable-background-networking',\n                    '--disable-background-timer-throttling',\n                    '--disable-backgrounding-occluded-windows',\n                    '--disable-breakpad',\n                    '--disable-component-extensions-with-background-pages',\n                    '--disable-renderer-backgrounding',\n                    '--enable-features=NetworkService,NetworkServiceInProcess',\n                    \n                    # === FINGERPRINTING PROTECTION ===\n                    '--disable-canvas-aa',\n                    '--disable-2d-canvas-clip-aa',\n                    '--disable-gl-drawing-for-tests',\n                    '--disable-accelerated-2d-canvas',\n                    '--disable-accelerated-mjpeg-decode',\n                    '--disable-accelerated-video-decode',\n                    \n                    # === APPARENCE R√âALISTE ===\n                    '--force-color-profile=srgb',\n                    '--hide-scrollbars',\n                    '--mute-audio',\n                    '--disable-logging',\n                    '--disable-login-animations',\n                    '--disable-notifications',\n                    \n                    # === STABILIT√â ===\n                    '--disable-gpu',\n                    '--disable-software-rasterizer',\n                    '--disable-background-mode'\n                ],\n                ignore_default_args=['--enable-automation', '--enable-blink-features=AutomationControlled']\n            )\n            \n            # R√©solutions d'√©cran ultra-r√©alistes\n            realistic_viewports = [\n                {'width': 1920, 'height': 1080},  # Full HD - le plus commun\n                {'width': 1366, 'height': 768},   # Laptop commun\n                {'width': 1536, 'height': 864},   # Scaling 125%\n                {'width': 1440, 'height': 900},   # MacBook\n                {'width': 1280, 'height': 720},   # HD\n                {'width': 2560, 'height': 1440}   # 2K\n            ]\n            viewport = random.choice(realistic_viewports)\n            \n            # Locales r√©alistes avec probabilit√©s\n            weighted_locales = [\n                ('en-US', 30), ('en-GB', 20), ('fr-FR', 15), \n                ('de-DE', 10), ('es-ES', 8), ('it-IT', 6), \n                ('pt-BR', 5), ('ja-JP', 3), ('zh-CN', 3)\n            ]\n            locale = random.choices(\n                [loc[0] for loc in weighted_locales],\n                weights=[loc[1] for loc in weighted_locales]\n            )[0]\n            \n            # Contexte navigateur ultra-r√©aliste\n            self.context = await self.browser.new_context(\n                user_agent=user_agent,\n                viewport=viewport,\n                locale=locale,\n                timezone_id='Europe/Paris',\n                \n                # === PERMISSIONS R√âALISTES ===\n                permissions=['geolocation', 'notifications', 'camera', 'microphone'],\n                geolocation={\n                    'latitude': 48.8566 + random.uniform(-0.1, 0.1),  # Paris avec variantes\n                    'longitude': 2.3522 + random.uniform(-0.1, 0.1)\n                },\n                \n                # === APPARENCE SYST√àME ===\n                color_scheme='light',\n                reduced_motion='no-preference',\n                forced_colors='none',\n                \n                # === DEVICE CHARACTERISTICS ===\n                has_touch=False,\n                is_mobile=False,\n                device_scale_factor=random.choice([1, 1.25, 1.5]),\n                \n                # === HEADERS ULTRA-R√âALISTES ===\n                extra_http_headers={\n                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',\n                    'Accept-Language': f'{locale},en;q=0.9,fr;q=0.8',\n                    'Accept-Encoding': 'gzip, deflate, br',\n                    'DNT': '1',\n                    'Connection': 'keep-alive',\n                    'Upgrade-Insecure-Requests': '1',\n                    'Sec-Fetch-Dest': 'document',\n                    'Sec-Fetch-Mode': 'navigate',\n                    'Sec-Fetch-Site': 'none',\n                    'Sec-Fetch-User': '?1',\n                    'Cache-Control': 'max-age=0',\n                    'sec-ch-ua': '\"Not A(Brand\";v=\"99\", \"Google Chrome\";v=\"121\", \"Chromium\";v=\"121\"',\n                    'sec-ch-ua-mobile': '?0',\n                    'sec-ch-ua-platform': '\"Windows\"'\n                },\n                \n                # === JAVA ET PLUGINS ===\n                java_script_enabled=True,\n                bypass_csp=True,\n                ignore_https_errors=True\n            )\n            \n            print(f\"   üîß Navigateur initialis√©: {user_agent[:50]}...\")\n            print(f\"   üìê R√©solution: {viewport['width']}x{viewport['height']}\")\n            print(f\"   üåç Locale: {locale}\")\n    \n    def _get_realistic_user_agent(self) -> str:\n        \"\"\"Obtenir un User-Agent ultra-r√©aliste\"\"\"\n        if self.ua:\n            # Pr√©f√©rer Chrome (le plus commun)\n            try:\n                return self.ua.chrome\n            except:\n                return self.ua.random\n        else:\n            return random.choice(self.fallback_agents)\n    \n    async def _inject_ultra_advanced_evasion_scripts(self, page):\n        \"\"\"\n        üõ°Ô∏è Injection des scripts anti-d√©tection les plus avanc√©s disponibles\n        Couvre 18+ techniques de masquage\n        \"\"\"\n        print(\"   üõ°Ô∏è Injection scripts anti-d√©tection ultra-avanc√©s...\")\n        \n        await page.add_init_script(\"\"\"\n            // ========================== MASQUAGE WEBDRIVER ==========================\n            \n            // 1. WEBDRIVER PROPERTY\n            Object.defineProperty(navigator, 'webdriver', {\n                get: () => undefined\n            });\n            \n            // 2. AUTOMATION FLAG\n            delete window.cdc_adoQpoasnfa76pfcZLmcfl_Array;\n            delete window.cdc_adoQpoasnfa76pfcZLmcfl_Promise;\n            delete window.cdc_adoQpoasnfa76pfcZLmcfl_Symbol;\n            \n            // ========================== CHROME RUNTIME ==========================\n            \n            // 3. CHROME OBJECT (critique pour Cloudflare)\n            window.chrome = {\n                runtime: {\n                    connect: () => {},\n                    sendMessage: () => {},\n                    onConnect: { addListener: () => {}, removeListener: () => {} },\n                    onMessage: { addListener: () => {}, removeListener: () => {} }\n                },\n                loadTimes: function() {\n                    return {\n                        commitLoadTime: Math.random() * 1000 + 1000,\n                        connectionInfo: 'h2',\n                        finishDocumentLoadTime: Math.random() * 1000 + 2000,\n                        finishLoadTime: Math.random() * 1000 + 2500,\n                        firstPaintAfterLoadTime: Math.random() * 100 + 50,\n                        firstPaintTime: Math.random() * 100 + 30,\n                        navigationType: 'Navigation',\n                        npnNegotiatedProtocol: 'h2',\n                        requestTime: Date.now() / 1000 - Math.random() * 10,\n                        startLoadTime: Date.now() / 1000 - Math.random() * 5,\n                        wasAlternateProtocolAvailable: false,\n                        wasFetchedViaSpdy: true,\n                        wasNpnNegotiated: true\n                    };\n                },\n                csi: function() {\n                    return {\n                        pageT: Math.random() * 1000 + 500,\n                        startE: Date.now() - Math.random() * 1000,\n                        tran: 15\n                    };\n                },\n                app: {\n                    isInstalled: false,\n                    InstallState: {\n                        DISABLED: 'disabled',\n                        INSTALLED: 'installed',\n                        NOT_INSTALLED: 'not_installed'\n                    },\n                    RunningState: {\n                        CANNOT_RUN: 'cannot_run',\n                        READY_TO_RUN: 'ready_to_run',\n                        RUNNING: 'running'\n                    }\n                }\n            };\n            \n            // ========================== PERMISSIONS ==========================\n            \n            // 4. PERMISSIONS API\n            const originalQuery = window.navigator.permissions.query;\n            window.navigator.permissions.query = (parameters) => {\n                const granted = ['notifications', 'geolocation'];\n                const denied = ['camera', 'microphone'];\n                \n                if (granted.includes(parameters.name)) {\n                    return Promise.resolve({ state: 'granted' });\n                } else if (denied.includes(parameters.name)) {\n                    return Promise.resolve({ state: 'denied' });\n                } else {\n                    return Promise.resolve({ state: 'prompt' });\n                }\n            };\n            \n            // ========================== PLUGINS ET MIMETYPES ==========================\n            \n            // 5. PLUGINS R√âALISTES\n            Object.defineProperty(navigator, 'plugins', {\n                get: () => {\n                    const plugins = [\n                        {\n                            0: {type: \"application/x-google-chrome-pdf\", suffixes: \"pdf\", description: \"Portable Document Format\"},\n                            description: \"Portable Document Format\",\n                            filename: \"internal-pdf-viewer\",\n                            length: 1,\n                            name: \"Chrome PDF Plugin\"\n                        },\n                        {\n                            0: {type: \"application/pdf\", suffixes: \"pdf\", description: \"\"},\n                            description: \"\",\n                            filename: \"mhjfbmdgcfjbbpaeojofohoefgiehjai\",\n                            length: 1,\n                            name: \"Chrome PDF Viewer\"\n                        },\n                        {\n                            0: {type: \"application/x-nacl\", suffixes: \"\", description: \"Native Client Executable\"},\n                            1: {type: \"application/x-pnacl\", suffixes: \"\", description: \"Portable Native Client Executable\"},\n                            description: \"\",\n                            filename: \"internal-nacl-plugin\",\n                            length: 2,\n                            name: \"Native Client\"\n                        }\n                    ];\n                    plugins.refresh = () => {};\n                    return plugins;\n                }\n            });\n            \n            // 6. MIMETYPES\n            Object.defineProperty(navigator, 'mimeTypes', {\n                get: () => {\n                    const mimeTypes = [\n                        {type: \"application/pdf\", suffixes: \"pdf\", description: \"Portable Document Format\", enabledPlugin: navigator.plugins[0]},\n                        {type: \"application/x-google-chrome-pdf\", suffixes: \"pdf\", description: \"Portable Document Format\", enabledPlugin: navigator.plugins[0]},\n                        {type: \"application/x-nacl\", suffixes: \"\", description: \"Native Client Executable\", enabledPlugin: navigator.plugins[2]},\n                        {type: \"application/x-pnacl\", suffixes: \"\", description: \"Portable Native Client Executable\", enabledPlugin: navigator.plugins[2]}\n                    ];\n                    mimeTypes.namedItem = (name) => mimeTypes.find(m => m.type === name);\n                    return mimeTypes;\n                }\n            });\n            \n            // ========================== LANGUES ET LOCALISATION ==========================\n            \n            // 7. LANGUAGES DYNAMIQUES\n            Object.defineProperty(navigator, 'languages', {\n                get: () => {\n                    const lang = navigator.language || 'en-US';\n                    const region = lang.split('-')[0];\n                    return [lang, region, 'en-US', 'en'];\n                }\n            });\n            \n            // ========================== WEBGL ET FINGERPRINTING ==========================\n            \n            // 8. WEBGL FINGERPRINTING PROTECTION\n            const getParameter = WebGLRenderingContext.prototype.getParameter;\n            WebGLRenderingContext.prototype.getParameter = function(parameter) {\n                const fakeValues = {\n                    37445: 'Intel Inc.',                    // UNMASKED_VENDOR_WEBGL\n                    37446: 'Intel Iris OpenGL Engine',      // UNMASKED_RENDERER_WEBGL\n                    7936: 'WebKit',                         // VENDOR\n                    7937: 'WebKit WebGL',                   // RENDERER\n                    35724: 'OpenGL ES GLSL ES 1.00 (WebGL)', // SHADING_LANGUAGE_VERSION\n                    7938: 'OpenGL ES 2.0 (WebGL)'          // VERSION\n                };\n                \n                return fakeValues[parameter] || getParameter.apply(this, [parameter]);\n            };\n            \n            // WebGL2 support\n            if (WebGL2RenderingContext) {\n                const getParameter2 = WebGL2RenderingContext.prototype.getParameter;\n                WebGL2RenderingContext.prototype.getParameter = WebGLRenderingContext.prototype.getParameter;\n            }\n            \n            // ========================== CANVAS FINGERPRINTING ==========================\n            \n            // 9. CANVAS NOISE INJECTION\n            const toBlob = HTMLCanvasElement.prototype.toBlob;\n            const toDataURL = HTMLCanvasElement.prototype.toDataURL;\n            const getImageData = CanvasRenderingContext2D.prototype.getImageData;\n            \n            const addCanvasNoise = (canvas, context) => {\n                const shift = {\n                    'r': Math.floor(Math.random() * 10) - 5,\n                    'g': Math.floor(Math.random() * 10) - 5,\n                    'b': Math.floor(Math.random() * 10) - 5,\n                    'a': Math.floor(Math.random() * 10) - 5\n                };\n                \n                const width = canvas.width || 300;\n                const height = canvas.height || 150;\n                \n                try {\n                    const imageData = getImageData.apply(context, [0, 0, width, height]);\n                    \n                    for (let i = 0; i < height; i++) {\n                        for (let j = 0; j < width; j++) {\n                            const n = ((i * (width * 4)) + (j * 4));\n                            imageData.data[n + 0] = Math.max(0, Math.min(255, imageData.data[n + 0] + shift.r));\n                            imageData.data[n + 1] = Math.max(0, Math.min(255, imageData.data[n + 1] + shift.g));\n                            imageData.data[n + 2] = Math.max(0, Math.min(255, imageData.data[n + 2] + shift.b));\n                            imageData.data[n + 3] = Math.max(0, Math.min(255, imageData.data[n + 3] + shift.a));\n                        }\n                    }\n                    \n                    context.putImageData(imageData, 0, 0);\n                } catch (e) {\n                    // Ignorer erreurs canvas\n                }\n            };\n            \n            HTMLCanvasElement.prototype.toDataURL = function(...args) {\n                addCanvasNoise(this, this.getContext('2d'));\n                return toDataURL.apply(this, args);\n            };\n            \n            // ========================== HARDWARE ET SYSTEM ==========================\n            \n            // 10. BATTERY API MOCKUP\n            Object.defineProperty(navigator, 'getBattery', {\n                get: () => () => Promise.resolve({\n                    charging: Math.random() > 0.5,\n                    chargingTime: Math.random() * 3600,\n                    dischargingTime: Math.random() * 7200 + 3600,\n                    level: Math.random() * 0.4 + 0.6,\n                    addEventListener: () => {},\n                    removeEventListener: () => {},\n                    dispatchEvent: () => true\n                })\n            });\n            \n            // 11. HARDWARE CONCURRENCY\n            Object.defineProperty(navigator, 'hardwareConcurrency', {\n                get: () => [4, 8, 12, 16][Math.floor(Math.random() * 4)]\n            });\n            \n            // 12. DEVICE MEMORY\n            Object.defineProperty(navigator, 'deviceMemory', {\n                get: () => [4, 8, 16][Math.floor(Math.random() * 3)]\n            });\n            \n            // 13. PLATFORM CONSISTENCY\n            Object.defineProperty(navigator, 'platform', {\n                get: () => 'Win32'\n            });\n            \n            Object.defineProperty(navigator, 'vendor', {\n                get: () => 'Google Inc.'\n            });\n            \n            // 14. CONNECTION INFO\n            Object.defineProperty(navigator, 'connection', {\n                get: () => ({\n                    effectiveType: ['slow-2g', '2g', '3g', '4g'][Math.floor(Math.random() * 4)],\n                    rtt: Math.floor(Math.random() * 100) + 20,\n                    downlink: Math.random() * 10 + 1,\n                    saveData: Math.random() > 0.8\n                })\n            });\n            \n            // ========================== SCREEN ET DISPLAY ==========================\n            \n            // 15. SCREEN PROPERTIES\n            Object.defineProperty(screen, 'availWidth', {\n                get: () => window.innerWidth || screen.width\n            });\n            Object.defineProperty(screen, 'availHeight', {\n                get: () => window.innerHeight || screen.height\n            });\n            \n            // ========================== TIMING ET DATE ==========================\n            \n            // 16. DATE TIMEZONE CONSISTENCY\n            const originalGetTimezoneOffset = Date.prototype.getTimezoneOffset;\n            Date.prototype.getTimezoneOffset = function() {\n                return -60; // UTC+1 (Paris)\n            };\n            \n            // 17. PERFORMANCE TIMING\n            if (performance && performance.timing) {\n                const timing = performance.timing;\n                const now = Date.now();\n                \n                Object.defineProperty(performance, 'timing', {\n                    get: () => ({\n                        ...timing,\n                        navigationStart: now - Math.random() * 1000,\n                        loadEventEnd: now - Math.random() * 100\n                    })\n                });\n            }\n            \n            // ========================== FRAMEWORKS DETECTION ==========================\n            \n            // 18. COMMON FRAMEWORKS MOCKUP\n            window.Modernizr = { _version: '3.11.7' };\n            window.jQuery = window.$ = { fn: { jquery: '3.6.0' } };\n            \n            // ========================== CONSOLE CLEANUP ==========================\n            \n            // 19. CLEAN CONSOLE\n            const originalLog = console.log;\n            console.log = function(...args) {\n                if (!args.some(arg => String(arg).includes('webdriver') || String(arg).includes('automation'))) {\n                    originalLog.apply(this, args);\n                }\n            };\n            \n            console.info('üõ°Ô∏è Ultra-advanced anti-detection scripts loaded successfully');\n        \"\"\")   \n    \n    async def _navigate_with_smart_retry(\n        self,\n        page,\n        url: str,\n        timeout_seconds: float,\n        max_retries: int = 3\n    ) -> bool:\n        \"\"\"Navigation intelligente avec retry adaptatif\"\"\"\n        for attempt in range(max_retries):\n            try:\n                print(f\"   üîÑ Navigation tentative {attempt + 1}/{max_retries}\")\n                \n                # D√©lai progressif entre tentatives\n                if attempt > 0:\n                    delay = 2 ** attempt + random.uniform(1, 3)\n                    print(f\"      ‚è∞ Attente {delay:.1f}s avant retry...\")\n                    await asyncio.sleep(delay)\n                \n                # Tentative de navigation\n                response = await page.goto(\n                    url,\n                    wait_until='domcontentloaded',\n                    timeout=int(timeout_seconds * 1000)\n                )\n                \n                # V√©rifier le statut de r√©ponse\n                if response and response.status >= 400:\n                    print(f\"      ‚ö†Ô∏è Status HTTP {response.status}\")\n                    if attempt < max_retries - 1:\n                        continue\n                \n                print(f\"      ‚úÖ Navigation r√©ussie\")\n                await asyncio.sleep(random.uniform(1, 2))\n                return True\n                \n            except PlaywrightTimeout:\n                print(f\"      ‚è∞ Timeout tentative {attempt + 1}\")\n                if attempt == max_retries - 1:\n                    return False\n            except Exception as e:\n                print(f\"      ‚ùå Erreur navigation: {str(e)[:100]}\")\n                if attempt == max_retries - 1:\n                    return False\n        \n        return False\n    \n    async def _wait_for_protections(self, page):\n        \"\"\"\n        üõ°Ô∏è D√©tecter et attendre la fin des protections (Cloudflare, WAF, etc.)\n        \"\"\"\n        print(\"   üîç D√©tection des protections...\")\n        \n        # S√©lecteurs de protection connus\n        protection_selectors = [\n            # Cloudflare\n            '#cf-wrapper', '.cf-browser-verification', '#challenge-form', \n            '.challenge-form', '[data-cf-settings]', '.cf-error-details',\n            \n            # Akamai\n            '#akamai_pixel', '.akamai-pixel',\n            \n            # Sucuri\n            '.sucuri-firewall', '#sucuri_cloudproxy_js',\n            \n            # Imperva/Incapsula\n            '#incap_ses', '.incap-logo',\n            \n            # Generic bot detection\n            '[class*=\"bot-detection\"]', '[id*=\"bot-check\"]', \n            '[class*=\"verification\"]', '[id*=\"challenge\"]'\n        ]\n        \n        protection_found = False\n        \n        for selector in protection_selectors:\n            try:\n                element = await page.wait_for_selector(\n                    selector,\n                    timeout=2000,\n                    state='attached'\n                )\n                \n                if element:\n                    protection_found = True\n                    print(f\"      üõ°Ô∏è Protection d√©tect√©e: {selector}\")\n                    print(\"      ‚è≥ Attente de la r√©solution...\")\n                    \n                    # Attendre que la protection disparaisse (max 45s)\n                    try:\n                        await page.wait_for_selector(\n                            selector,\n                            timeout=45000,\n                            state='detached'\n                        )\n                        print(\"      ‚úÖ Protection r√©solue !\")\n                        \n                        # Attendre un d√©lai suppl√©mentaire pour stabilit√©\n                        await asyncio.sleep(random.uniform(2, 4))\n                        break\n                        \n                    except PlaywrightTimeout:\n                        print(\"      ‚ö†Ô∏è Timeout r√©solution protection\")\n                        break\n                        \n            except PlaywrightTimeout:\n                continue  # Protection non trouv√©e, continuer\n            except Exception:\n                continue  # Erreur, ignorer\n        \n        if not protection_found:\n            print(\"      ‚úÖ Aucune protection d√©tect√©e\")\n        \n        # Attente additionnelle pour les protections invisibles\n        await asyncio.sleep(random.uniform(1, 2))\n    \n    async def _ultra_realistic_human_simulation(self, page):\n        \"\"\"\n        ü§ñ‚û°Ô∏èüë§ Simulation comportement humain ULTRA-r√©aliste\n        \"\"\"\n        try:\n            print(\"   üë§ Simulation comportement humain ultra-r√©aliste...\")\n            \n            # 1. Mouvements de souris naturels multiples\n            for _ in range(random.randint(5, 10)):\n                # Mouvement courbe r√©aliste\n                start_x = random.randint(100, 500)\n                start_y = random.randint(100, 400)\n                end_x = random.randint(600, 1800)\n                end_y = random.randint(300, 900)\n                \n                # Mouvement avec courbe (plus humain)\n                mid_x = (start_x + end_x) // 2 + random.randint(-200, 200)\n                mid_y = (start_y + end_y) // 2 + random.randint(-100, 100)\n                \n                await page.mouse.move(start_x, start_y)\n                await asyncio.sleep(random.uniform(0.05, 0.1))\n                await page.mouse.move(mid_x, mid_y, steps=random.randint(10, 20))\n                await asyncio.sleep(random.uniform(0.05, 0.1))\n                await page.mouse.move(end_x, end_y, steps=random.randint(15, 30))\n                await asyncio.sleep(random.uniform(0.1, 0.3))\n            \n            # 2. Scrolls l√©gers et irr√©guliers\n            for _ in range(random.randint(2, 4)):\n                scroll_delta = random.randint(50, 300) * random.choice([-1, 1])\n                await page.mouse.wheel(0, scroll_delta)\n                await asyncio.sleep(random.uniform(0.3, 0.8))\n            \n            # 3. Hover sur des √©l√©ments interactifs\n            interactive_elements = await page.query_selector_all(\n                'a, button, input, [onclick], [role=\"button\"], .btn'\n            )\n            \n            if interactive_elements:\n                elements_to_hover = random.sample(\n                    interactive_elements, \n                    min(random.randint(2, 5), len(interactive_elements))\n                )\n                \n                for element in elements_to_hover:\n                    try:\n                        box = await element.bounding_box()\n                        if box and box['width'] > 0 and box['height'] > 0:\n                            # Hover avec mouvement naturel\n                            hover_x = box['x'] + box['width'] * random.uniform(0.2, 0.8)\n                            hover_y = box['y'] + box['height'] * random.uniform(0.2, 0.8)\n                            \n                            await page.mouse.move(\n                                hover_x, hover_y, \n                                steps=random.randint(5, 15)\n                            )\n                            await asyncio.sleep(random.uniform(0.2, 0.6))\n                    except:\n                        continue\n            \n            # 4. Clicks \"accidentels\" hors des √©l√©ments\n            for _ in range(random.randint(1, 3)):\n                safe_x = random.randint(300, 1200)\n                safe_y = random.randint(200, 600)\n                \n                await page.mouse.click(safe_x, safe_y, delay=random.randint(50, 150))\n                await asyncio.sleep(random.uniform(0.2, 0.5))\n            \n            # 5. Simulation frappe clavier (si input visible)\n            inputs = await page.query_selector_all('input[type=\"text\"], input[type=\"search\"], textarea')\n            if inputs and random.random() > 0.7:  # 30% de chance\n                try:\n                    input_element = random.choice(inputs)\n                    await input_element.click()\n                    await asyncio.sleep(random.uniform(0.3, 0.7))\n                    \n                    # Frappe quelques caract√®res puis delete\n                    test_text = random.choice(['test', 'hello', 'search', ''])\n                    await input_element.type(test_text, delay=random.randint(100, 300))\n                    await asyncio.sleep(random.uniform(0.5, 1))\n                    \n                    # Tout s√©lectionner et supprimer\n                    await page.keyboard.press('Control+a')\n                    await page.keyboard.press('Backspace')\n                    \n                except:\n                    pass\n            \n            print(\"      ‚úÖ Simulation comportement termin√©e\")\n            \n        except Exception as e:\n            print(f\"      ‚ö†Ô∏è Erreur simulation humaine: {str(e)[:50]}\")\n            # Continuer m√™me en cas d'erreur\n    \n    async def _ultra_human_like_scroll(self, page):\n        \"\"\"\n        üìú Scroll ultra-r√©aliste qui imite parfaitement un humain\n        \"\"\"\n        await page.evaluate(\"\"\"\n            async () => {\n                await new Promise((resolve) => {\n                    let totalHeight = 0;\n                    let scrollCount = 0;\n                    const maxScrolls = Math.floor(Math.random() * 8) + 4;\n                    const scrollHeight = document.body.scrollHeight;\n                    \n                    const performScroll = () => {\n                        if (scrollCount >= maxScrolls || totalHeight >= scrollHeight) {\n                            // Retour en haut avec scroll humain\n                            const returnToTop = () => {\n                                const currentY = window.pageYOffset;\n                                if (currentY > 100) {\n                                    const scrollStep = Math.floor(Math.random() * 200) + 100;\n                                    window.scrollBy(0, -scrollStep);\n                                    setTimeout(returnToTop, Math.random() * 150 + 50);\n                                } else {\n                                    window.scrollTo(0, 0);\n                                    resolve();\n                                }\n                            };\n                            \n                            setTimeout(() => {\n                                returnToTop();\n                            }, Math.random() * 1000 + 500);\n                            return;\n                        }\n                        \n                        // Scroll irr√©gulier et naturel\n                        const baseDistance = 150;\n                        const variation = Math.floor(Math.random() * 100) - 50;\n                        const scrollDistance = baseDistance + variation;\n                        \n                        // Parfois pause plus longue (lecture)\n                        const isReading = Math.random() > 0.7;\n                        const scrollDelay = isReading ? \n                            Math.random() * 2000 + 1000 : \n                            Math.random() * 300 + 100;\n                        \n                        // Parfois scroll arri√®re (correction humaine)\n                        const direction = (Math.random() > 0.1) ? 1 : -0.3;\n                        const finalDistance = scrollDistance * direction;\n                        \n                        window.scrollBy(0, finalDistance);\n                        totalHeight += Math.abs(finalDistance);\n                        scrollCount++;\n                        \n                        setTimeout(performScroll, scrollDelay);\n                    };\n                    \n                    // D√©lai initial al√©atoire\n                    setTimeout(performScroll, Math.random() * 1000 + 300);\n                });\n            }\n        \"\"\")\n        \n        print(\"      ‚úÖ Scroll humain termin√©\")"